module rx_afe (
    input  electrical vin,      // input signal
    input  aEn, aPc,            // path A enable, precharge
    input  bEn, bPc,            // path B enable, precharge
    input  selA,                // select A or B for output
    output electrical vout      // output signal
);

    // Internal storage nodes (the sampling capacitors)
    electrical va, vb;

    // Parameters
    parameter real Ca = 1p;     // Sample capacitor A
    parameter real Cb = 1p;     // Sample capacitor B
    parameter real Ron = 5.0;   // Switch on resistance
    parameter real Roff = 1e12; // Switch off resistance
    parameter real Rout = 2.0;  // Output buffer resistance
    parameter real Vmid = 0.5;  // Precharge target

    // Helper function for switch resistance
    function real sw(input logic ctrl);
        if (ctrl == 1'b1) sw = Ron;
        else              sw = Roff;
    endfunction

    // Analog behavior
    analog begin

        //
        // Path A capacitor
        //
        I(va) <+ Ca * ddt(V(va));

        //
        // Path B capacitor
        //
        I(vb) <+ Cb * ddt(V(vb));

        //
        // Sampling switches
        //
        V(vin, va) <+ I(vin, va) * sw(aEn);
        V(vin, vb) <+ I(vin, vb) * sw(bEn);

        //
        // Precharge switches (drive capacitor node toward Vmid)
        //
        V(Vmid, va) <+ I(Vmid, va) * sw(aPc);
        V(Vmid, vb) <+ I(Vmid, vb) * sw(bPc);

        //
        // Output selection multiplexer
        //
        if (selA == 1'b1) begin
            V(va, vout) <+ I(va, vout) * Rout;
        end else begin
            V(vb, vout) <+ I(vb, vout) * Rout;
        end

    end

endmodule

module deserializer #(
    parameter integer N = 8     // width of parallel output
)(
    input  logic       clk,     // serial input clock
    input  logic       rst,     // synchronous reset
    input  logic       din,     // serial data in
    output logic [N-1:0] pdata, // parallel output
    output logic       pvalid   // pulses 1 cycle when pdata is valid
);

    // Internal shift register
    logic [N-1:0] shift_reg;
    integer count;

    //
    // Main deserialization process
    //
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            shift_reg <= '0;
            count     <= 0;
            pdata     <= '0;
            pvalid    <= 1'b0;
        end else begin

            // Shift new bit into LSB or MSB depending on convention
            shift_reg <= {shift_reg[N-2:0], din};
            count     <= count + 1;

            // When N bits collected:
            if (count == N-1) begin
                pdata  <= {shift_reg[N-2:0], din};
                pvalid <= 1'b1;
                count  <= 0;
            end else begin
                pvalid <= 1'b0;
            end
        end
    end

endmodule
