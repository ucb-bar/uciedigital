// 32:1 binary-tree serializer with DDR output
// - Output updates on both rising and falling clock edges
// - Pointer advances by 2 every clock edge
// - New 32-bit word is sampled automatically every 32 bits
// Behavioral VAMS model

`timescale 1ns/1ps

module binary_tree_serializer_ddr_vams #(
    parameter integer N       = 32,
    parameter integer SEL_W   = 5,
    parameter real    T_STAGE = 0.5e-9,
    parameter real    T_REG   = 0.2e-9
) (
    input  logic [N-1:0] data_in,
    input  logic         clk,
    input  logic         rst_n,
    output logic         serial_out
);

    logic [N-1:0] latched;
    logic [SEL_W-1:0] ptr;        // always even index (0,2,4,...,30)

    // ============================================================
    // Pointer + auto-reload
    // ============================================================
    // ptr increments by 2 on *every clock edge* → DDR
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            ptr     <= 0;
            latched <= 0;
        end else begin
            // If ptr == 0, we reload on this clock edge
            if (ptr == 0)
                latched <= data_in;

            // Advance pointer by 2, wrap at 32
            if (ptr == N-2)
                ptr <= 0;
            else
                ptr <= ptr + 2;
        end
    end

    // ============================================================
    // Multiplexer tree for two indices:
    //   idx_even = ptr
    //   idx_odd  = ptr + 1
    // ============================================================
    wire bit_even;
    wire bit_odd;

    // Helper function: binary-tree select for an arbitrary index
    function automatic logic tree_select (
        input logic [N-1:0] dword,
        input logic [SEL_W-1:0] idx
    );
        integer s1, s2, s3, s4;
        logic [15:0] st1;
        logic [7:0]  st2;
        logic [3:0]  st3;
        logic [1:0]  st4;

        begin
            // Stage 1: 32 → 16
            for (s1 = 0; s1 < 16; s1++)
                st1[s1] = idx[0] ? dword[2*s1+1] : dword[2*s1];

            // Stage 2: 16 → 8
            for (s2 = 0; s2 < 8;  s2++)
                st2[s2] = idx[1] ? st1[2*s2+1] : st1[2*s2];

            // Stage 3: 8 → 4
            for (s3 = 0; s3 < 4;  s3++)
                st3[s3] = idx[2] ? st2[2*s3+1] : st2[2*s3];

            // Stage 4: 4 → 2
            for (s4 = 0; s4 < 2;  s4++)
                st4[s4] = idx[3] ? st3[2*s4+1] : st3[2*s4];

            // Final stage: 2 → 1
            tree_select = idx[4] ? st4[1] : st4[0];
        end
    endfunction

    // Evaluate both DDR sub-bits through the mux tree (with delays)
    assign #(T_STAGE) bit_even = tree_select(latched, ptr);
    assign #(T_STAGE) bit_odd  = tree_select(latched, ptr + 1);

    // ============================================================
    // DDR output flop
    // ============================================================

    always_ff @(posedge clk or negedge rst_n)
        if (!rst_n) serial_out <= 0;
        else        serial_out <= #(T_REG) bit_even;

    always_ff @(negedge clk or negedge rst_n)
        if (!rst_n) serial_out <= 0;
        else        serial_out <= #(T_REG) bit_odd;

endmodule

