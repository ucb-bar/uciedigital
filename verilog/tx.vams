module driver (
    input din,
    input [`DRIVER_CTL_BITS-1:0] pu_ctl, pd_ctlb,
    input en, enb,
    output dout,
    inout vdd, vss
);
    electrical din, dout, vdd, vss;

    integer i, pu_on, pd_on;
    analog begin
        // Enable pull-up segments
        I(vdd, dout) <+ V(vdd, dout) / (
            (
                (1 - V(din, vss)/`VDD*transition(en, 0, `T_RISE_FALL_DEFAULT * 1p))
                * (`DRIVER_R_OFF_SEGMENT - `DRIVER_R_SEGMENT)
                + `DRIVER_R_SEGMENT
            )
        ) *  (`DRIVER_SEGMENTS - `DRIVER_CTL_BITS);
        // Enable pull-down segments
        I(dout, vss) <+ V(dout, vss) / (
            (
                (1 - (1 - V(din, vss)/`VDD)*transition(!enb, 0, `T_RISE_FALL_DEFAULT * 1p))
                * (`DRIVER_R_OFF_SEGMENT - `DRIVER_R_SEGMENT)
                + `DRIVER_R_SEGMENT
            )
        ) * (`DRIVER_SEGMENTS - `DRIVER_CTL_BITS);

        // Control pull-up segments
        pu_on = 0;
        for (i = 0; i < `DRIVER_CTL_BITS; i=i+1) begin
            if (pu_ctl[i])
                pu_on = pu_on + 1;
        end
        I(vdd, dout) <+ V(vdd, dout) / `DRIVER_R_SEGMENT * V(din, vss)/`VDD * transition(pu_on, 0, `T_RISE_FALL_DEFAULT * 1p);
        I(vdd, dout) <+ V(vdd, dout) / `DRIVER_R_OFF_SEGMENT * (`DRIVER_CTL_BITS - V(din, vss)/`VDD * transition(pu_on, 0, `T_RISE_FALL_DEFAULT * 1p));

        // Control pull-down segments
        pd_on = 0;
        for (i = 0; i < `DRIVER_CTL_BITS; i=i+1) begin
            if (!pd_ctlb[i])
                pd_on = pd_on + 1;
        end
        I(dout, vss) <+ V(dout, vss) / `DRIVER_R_SEGMENT * (1 - V(din, vss)/`VDD) * transition(pd_on, 0, `T_RISE_FALL_DEFAULT * 1p);
        I(dout, vss) <+ V(dout, vss) / `DRIVER_R_OFF_SEGMENT * (`DRIVER_CTL_BITS - (1 - V(din, vss)/`VDD) * transition(`DRIVER_CTL_BITS - pd_on, 0, `T_RISE_FALL_DEFAULT * 1p));
    end
endmodule

module driver_data_tb;
    localparam CYCLES = 16;    // number of test cycles
    reg din;
    reg [`DRIVER_CTL_BITS-1:0] pu_ctl, pd_ctlb;
    reg en, enb;
    electrical dout;
    electrical vdd, vss;
    real dout_sample;
    
    driver drv (
        .din(din),
        .pu_ctl(pu_ctl),
        .pd_ctlb(pd_ctlb),
        .en(en),
        .enb(enb),
        .dout(dout),
        .vdd(vdd),
        .vss(vss)
    );

    analog begin
        V(vdd) <+ `VDD;
        V(vss) <+ 0;
        dout_sample = V(dout);
    end

    initial begin
        pu_ctl = 0;
        pd_ctlb = {`DRIVER_CTL_BITS{1'b1}};
        en = 1;
        enb = 0;
    end

    integer i;
    reg actual;
    initial begin
        din = 0;
        #300;


        // Apply random inputs and check functionality
        for (i = 0; i < CYCLES; i=i+1) begin
            din = $random % 2;
            #300;
            actual = dout_sample > `VDD/2;
            $display("din = %b, dout = %b (analog %f V)", din, actual, dout_sample);
            if (actual !== din)
                $display("Error: dout does not match din");
        end

        $finish;
    end
endmodule

module driver_impedance_tb;
    // TODO: Verify step size
    reg din;
    reg [`DRIVER_CTL_BITS-1:0] pu_ctl, pd_ctlb;
    reg en, enb;
    electrical dout;
    electrical vdd, vss;
    real dout_sample;
    
    driver drv (
        .din(din),
        .pu_ctl(pu_ctl),
        .pd_ctlb(pd_ctlb),
        .en(en),
        .enb(enb),
        .dout(dout),
        .vdd(vdd),
        .vss(vss)
    );

    analog begin
        V(vdd) <+ `VDD;
        V(vss) <+ 0;
        I(dout, vss) <+ V(dout, vss) / 50;
        I(vdd, dout) <+ V(vdd, dout) / 50;
        dout_sample = V(dout);
    end

    initial begin
        pu_ctl = 0;
        pd_ctlb = {`DRIVER_CTL_BITS{1'b1}};
        en = 1;
        enb = 0;
    end

    integer i;
    reg actual;
    real rtest;
    real r30;
    real vpu;
    real vpd;
    initial begin
        rtest = 50;
        r30 = 1/(1/`TX_R_OUT + 1/rtest);
        vpu = rtest / (r30 + rtest) * `VDD;
        vpd = r30 / (r30 + rtest) * `VDD;
        din = 0;
        #300;

        // Check that lowest code is above 30 ohms
        $display("din = %b, pd_ctlb = %b, dout = %f", din, pd_ctlb, dout_sample);
        if (dout_sample < vpd) $display("Error: highest pull-down impedance is too low (vpd = %f)", vpd);
        pd_ctlb = 0;
        #300;
        $display("din = %b, pd_ctlb = %b, dout = %f", din, pd_ctlb, dout_sample);
        if (dout_sample > vpd) $display("Error: lowest pull-down impedance is too high (vpd = %f)", vpd);
        din = 1;
        #300;
        $display("din = %b, pu_ctl = %b, dout = %f", din, pu_ctl, dout_sample);
        if (dout_sample > vpu) $display("Error: highest pull-up impedance is too low (vpu = %f)", vpu);
        pu_ctl = {`DRIVER_CTL_BITS{1'b1}};
        #300;
        $display("din = %b, pu_ctl = %b, dout = %f", din, pu_ctl, dout_sample);
        if (dout_sample < vpu) $display("Error: lowest pull-up impedance is too high (vpu = %f)", vpu);


        $finish;
    end
endmodule
