// ============================================================================
// Single-to-Differential (S2D) Converter - Verilog-A Behavioral Model
// ============================================================================
//
// ============================================================================
// NOTE: TRANSIENT NOISE RECOMMENDED FOR REALISTIC JITTER SIMULATION
// ============================================================================
//
// This S2D model includes phase noise modeling (white + flicker noise) for
// both differential outputs to simulate realistic timing jitter. For best
// accuracy, enable transient noise in Spectre simulations.
//
// To enable transient noise in Spectre:
//   1. In ADE: Simulation → Options → Analog → Set "noisefmax" parameter
//      Example: noisefmax=64G (should exceed clock_frequency)
//   2. In netlist: Add "noisefmax=64G" to the transient analysis statement
//      Example: tran tran stop=100n noisefmax=64G
//   3. Command line: spectre +aps netlist.scs +noisefmax=64G
//
// Recommended noisefmax: At least 2× the input clock frequency
//
// ============================================================================
//
// Description:
//   A single-ended to differential clock converter with edge-triggered
//   regeneration, realistic phase noise modeling, and path mismatch. Converts
//   a single-ended clock input into true differential outputs (clk_outp and
//   clk_outn) with independent noise sources and static manufacturing mismatch.
//
// IMPORTANT - Output Waveform Behavior:
//   This model uses EDGE-TRIGGERED regeneration - it detects rising/falling
//   edges of the input and generates corresponding delayed transitions at both
//   differential outputs. The output waveform shapes are synthesized with
//   controlled parameters, NOT copied from input.
//   
//   This means:
//   - Input timing (edge positions) IS preserved (with delay + jitter + mismatch)
//   - Input waveform shape (slew rate, amplitude) IS NOT preserved
//   - Outputs have clean rail-to-rail transitions with controlled slew rate
//   - Each differential path has independent noise and path delay
//   - Suitable for clock distribution where timing accuracy matters
//
// Operation:
//   1. Input rising edge detected → clk_outp rises, clk_outn falls (after delays)
//   2. Input falling edge detected → clk_outp falls, clk_outn rises (after delays)
//   3. Each path has: delay + random_mismatch ± jitter_sampled
//   4. Jitter sampled at each input edge (both rising and falling)
//   5. Path mismatch is static (randomized once at initialization)
//
// Differential Path Characteristics:
//   - Processing Delay: Nominal delay through converter (default: 20ps)
//   - Static Path Mismatch: Random timing offset between P and N paths
//     • Randomized at initialization to model manufacturing variation
//     • Sampled from uniform distribution: ±max_time_unbalance
//     • Derived from max_phase_unbalance parameter
//   - Maximum Phase Unbalance: User-specified in degrees (default: 5°)
//   - Time Unbalance Conversion: Δt = max_phase_unbalance / (360° × f_clk)
//
// Noise Modeling:
//   - Independent noise sources for each differential path (P and N)
//   - White Noise: Flat phase noise floor, filtered at Nyquist frequency
//   - Flicker Noise: 1/f phase noise contribution
//   - Noise scaled by inverter_count to model cumulative stage effects
//   - Phase noise converted to timing jitter: Δt = Δφ / (2π × f_clk)
//   - Jitter sampled at each input edge transition (discrete, sample-and-hold)
//   - Each edge gets new independent jitter samples for both paths
//
// Ports:
//   clk_in   - Input, single-ended clock signal (electrical)
//              Only edge timing is used; waveform shape is ignored
//   clk_outp - Output, positive differential clock output (electrical)
//              Rail-to-rail signal (0 to vdd) with controlled slew rate
//              Follows clk_in: high when input high, low when input low
//   clk_outn - Output, negative differential clock output (electrical)
//              Rail-to-rail signal (0 to vdd) with controlled slew rate
//              Inverted from clk_in: low when input high, high when input low
//
// Parameters:
//   vdd                       - Supply voltage / output signal amplitude (default: 0.75V)
//   delay                     - Nominal processing delay through converter (default: 20ps)
//   t_slew                    - Output transition (rise/fall) time (default: 5ps)
//   max_phase_unbalance       - Maximum static phase mismatch in degrees (default: 5°)
//                               Converted to time: ±max_phase_unbalance/(360×f_clk)
//   clock_frequency           - Input clock frequency for noise modeling (default: 8GHz)
//   inverter_count            - Number of inverter stages per path (default: 2)
//                               Higher count = more cumulative noise
//   white_noise_floor_dBcHz   - White phase noise floor per single inverter (default: -160 dBc/Hz)
//   flicker_noise_1Hz_dBcHz   - Flicker phase noise at 1Hz offset per inverter (default: -109 dBc/Hz)
//
// ============================================================================

`include "constants.vams"
`include "disciplines.vams"

module s2d(clk_in, clk_outp, clk_outn);
    input clk_in; electrical clk_in;
    output clk_outp; electrical clk_outp;
    output clk_outn; electrical clk_outn;

    parameter real vdd = 0.75;
    parameter real delay = 20p; // processing delay
    parameter real max_phase_unbalance = 5; // maximum phase unbalance in degrees
    parameter real clock_frequency = 8G; // input clock frequency
    parameter real inverter_count = 2; // number of inverters in each output path, used to model noise
    parameter real white_noise_floor_dBcHz = -160; // white phase noise floor introduced by one single inverter
    parameter real flicker_noise_1Hz_dBcHz = -109; // flicker phase noise at 1Hz offset introduced by one single inverter
    parameter real t_slew = 5p; // output transition time

    real max_time_unbalance;
    real random_unbalance;
    integer seed;
    real white_noise_floor_linear;
    real white_noise_td_p, white_noise_td_n;
    real white_noise_filtered_p, white_noise_filtered_n;
    real flicker_noise_1Hz_linear;
    real flicker_noise_td_p, flicker_noise_td_n;
    real total_phase_noise_p, total_phase_noise_n;
    real total_time_noise_sampled_p, total_time_noise_sampled_n;  // Sampled jitter for each path
    real delay_max;
    integer sign_p, sign_n;  // Track differential output states
    
    analog initial begin
        total_time_noise_sampled_p = 0;
        total_time_noise_sampled_n = 0;
        sign_p = 0;
        sign_n = 1;
    end

    analog begin
        // Initialize random seed once at start based on current time
        @(initial_step) begin
            seed = $random + $abstime * 1e12;  // Use $random and timestamp to create unique seed
            total_time_noise_sampled_p = 0;
            total_time_noise_sampled_n = 0;
        end
        
        // Calculate maximum time unbalance from phase unbalance
        max_time_unbalance = max_phase_unbalance / 360.0 / clock_frequency;
        
        // Model the phase noise introduced by the S2D for both outputs
        // Model one single inverter, then scale the noise by inverter count
        white_noise_floor_linear = 10**(white_noise_floor_dBcHz/10);
        white_noise_td_p = white_noise(inverter_count * white_noise_floor_linear);
        white_noise_td_n = white_noise(inverter_count * white_noise_floor_linear);
        
        // Filter the white noise at Nyquist frequency to prevent folding
        white_noise_filtered_p = laplace_nd(white_noise_td_p, {1.0}, {1.0, 1.0/(`M_PI*clock_frequency)});
        white_noise_filtered_n = laplace_nd(white_noise_td_n, {1.0}, {1.0, 1.0/(`M_PI*clock_frequency)});
        
        flicker_noise_1Hz_linear = 10**(flicker_noise_1Hz_dBcHz/10);
        flicker_noise_td_p = flicker_noise(inverter_count * flicker_noise_1Hz_linear, 1);
        flicker_noise_td_n = flicker_noise(inverter_count * flicker_noise_1Hz_linear, 1);
        
        total_phase_noise_p = white_noise_filtered_p + flicker_noise_td_p;
        total_phase_noise_n = white_noise_filtered_n + flicker_noise_td_n;
        
        // Sample noise at each input edge transition (both rising and falling)
        @(cross(V(clk_in) - vdd/2, 0)) begin
            total_time_noise_sampled_p = total_phase_noise_p / (2 * `M_PI * clock_frequency);
            total_time_noise_sampled_n = total_phase_noise_n / (2 * `M_PI * clock_frequency);
        end
        
        delay_max = delay + max_time_unbalance;
        
        // Generate random unbalance for differential path mismatch (static, set at initialization)
        @(initial_step) begin
            random_unbalance = $rdist_uniform(seed, -max_time_unbalance, max_time_unbalance);
        end
        
        // Detect input edges and toggle differential outputs
        @(cross(V(clk_in) - vdd/2, 1)) begin
            sign_p = 1;
            sign_n = 0;
        end
        @(cross(V(clk_in) - vdd/2, -1)) begin
            sign_p = 0;
            sign_n = 1;
        end
        
        // Generate differential outputs with sampled noise
        V(clk_outp) <+ transition(vdd * sign_p, delay + random_unbalance + total_time_noise_sampled_p - t_slew / 2, t_slew);
        V(clk_outn) <+ transition(vdd * sign_n, delay - random_unbalance + total_time_noise_sampled_n - t_slew / 2, t_slew);
    end



endmodule
