// Verilog-A model for a digital loop filter: Kp + Ki/(1-z^-1) used in a digital PLL

`include "constants.vams"
`include "disciplines.vams"

module model_digital_loop_filter(clk, reset, early, late, Dinteger, Dfrac, Dctrl);

input clk;       electrical clk;
input reset;     electrical reset;     // active high reset
input early;     electrical early;     // unused, kept for interface compatibility
input late;      electrical late;
output Dinteger; electrical Dinteger;
output Dfrac;    electrical Dfrac;
output Dctrl;    electrical Dctrl;

parameter real digital_latency = 500p;
parameter real trise = 50p;
parameter real vdd = 0.85;
parameter real dlf_bitwidth = 8;
parameter real dctrl_reset_value = 128;
parameter integer rise_p1_fall_m1 = 1;
parameter real Kp = 1;
parameter real Ki = 1;

real integrator_state = dctrl_reset_value / Ki;
real late_p1_early_m1;
real Dctrl_value;

analog begin
    // Phase detector output: +1 if late, -1 if early
    if (V(late) > vdd/2)
        late_p1_early_m1 = 1;
    else
        late_p1_early_m1 = -1;

    // Update integrator on clock edge
    @(cross(V(clk) - vdd/2, rise_p1_fall_m1)) begin
        if (V(reset) > vdd/2) begin
            integrator_state = dctrl_reset_value / Ki;
        end else begin
            // Anti-overflow protection
            if (integrator_state * Ki + late_p1_early_m1 * Kp < 2**dlf_bitwidth - 1 &&
                integrator_state * Ki + late_p1_early_m1 * Kp > 0) begin
                integrator_state = integrator_state + late_p1_early_m1;
            end
        end
    end
    
    // Calculate PI controller output with flooring for integer part
    Dctrl_value = Ki * integrator_state + Kp * late_p1_early_m1;
    V(Dinteger) <+ transition($floor(Dctrl_value), digital_latency, trise);
    V(Dfrac) <+ transition(Dctrl_value - $floor(Dctrl_value), digital_latency, trise);
    V(Dctrl) <+ transition(Dctrl_value, digital_latency, trise);
end

endmodule
