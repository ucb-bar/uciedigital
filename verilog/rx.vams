module rx_afe(
    inout vref,
    input din,
    input a_en,
    input a_pc,
    input b_en,
    input b_pc,
    input sel_a,
    output dout,
    inout vdd,
    inout vss
);
    electrical vref, din, dout, vdd, vss, a_cap_p, a_cap_n, b_cap_p, b_cap_n, mux_a_b, mux_a, mux_b_b, mux_b;

    sw a_sw_pc(.p(vref), .n(a_cap_p), .s(a_pc));
    sw b_sw_pc(.p(vref), .n(b_cap_p), .s(b_pc));
    sw a_sw_zero(.p(a_cap_n), .n(mux_a_b), .s(a_pc));
    sw b_sw_zero(.p(b_cap_n), .n(mux_b_b), .s(b_pc));
    sw a_sw_en(.p(din), .n(a_cap_p), .s(a_en));
    sw b_sw_en(.p(din), .n(b_cap_p), .s(b_en));

    cap ca(.p(a_cap_p), .n(a_cap_n));
    cap cb(.p(b_cap_p), .n(b_cap_n));
    
    inv a_inv_pc(.a(a_cap_n), .o(mux_a_b), .vdd(vdd), .vss(vss));
    inv b_inv_pc(.a(b_cap_n), .o(mux_b_b), .vdd(vdd), .vss(vss));
    inv a_inv_d(.a(mux_a_b), .o(mux_a), .vdd(vdd), .vss(vss));
    inv b_inv_d(.a(mux_b_b), .o(mux_b), .vdd(vdd), .vss(vss));

    mux m(.a(mux_a), .b(mux_b), .sel_a(sel_a), .o(dout));
endmodule

module tb_rx_afe;
    parameter CYCLES = 16;    // number of test cycles

    reg a_en, a_pc, b_en, b_pc, sel_a, din_dig;
    electrical vref, din, vdd, vss;
    wire dout;
    rx_afe afe(
        .vref(vref),
        .din(din),
        .a_en(a_en),
        .a_pc(a_pc),
        .b_en(b_en),
        .b_pc(b_pc),
        .sel_a(sel_a),
        .dout(dout),
        .vdd(vdd),
        .vss(vss)
    );

    analog begin
        V(vdd) <+ `VDD;
        V(vss) <+ 0;
        V(vref) <+ `RX_V_HIGH / 2;
        V(din) <+ din_dig * `RX_V_HIGH;
    end

    initial begin
        a_pc = 1;
        b_pc = 1;
        a_en = 0;
        b_en = 0;
        sel_a = 1;
    end

    initial begin
        #1000;
        forever begin
            a_pc = 0;
            #100;
            a_en = 1;
            #100;
            sel_a = 1;
            #100;
            b_en = 0;
            #100;
            b_pc = 1;
            #1000;
            b_pc = 0;
            #100;
            b_en = 1;
            #100;
            sel_a = 0;
            #100;
            a_en = 0;
            #100;
            a_pc = 1;
            #1000;
        end
    end

    integer i;
    initial begin
        din_dig = 0;
        $display("waiting for a_pc");
        @(negedge a_pc);
        #300;


        // Apply random inputs
        for (i = 0; i < CYCLES; i=i+1) begin
            din_dig = $random % 2;
            #300;
            $display("din = %b, dout %b", din_dig, dout);
            if (dout !== din_dig)
                $display("Error: dout does not match din");
        end

        $finish;
    end

endmodule


module termination(
    input vin,
    input en,
    input [`TERMINATION_CTL_BITS-1:0] zctl,
    inout vss
);
    electrical vin, vss;

    integer i;
    integer num_on;
    analog begin
        I(vin, vss) <+ V(vin, vss) / (
            (
                transition(1 - en, 0, `T_RISE_FALL_DEFAULT * 1p)
                * (`TERMINATION_R_OFF_SEGMENT - `TERMINATION_R_SEGMENT)
                + `TERMINATION_R_SEGMENT
            )
        ) * (`TERMINATION_SEGMENTS - `TERMINATION_CTL_BITS);
        num_on = 0;
        for (i = 0; i < `TERMINATION_CTL_BITS; i=i+1) begin
            if (zctl[i])
                num_on = num_on + 1;
        end
        I(vin, vss) <+ V(vin, vss) / `TERMINATION_R_SEGMENT * transition(num_on, 0, `T_RISE_FALL_DEFAULT * 1p);
        I(vin, vss) <+ V(vin, vss) / `TERMINATION_R_OFF_SEGMENT * transition(`TERMINATION_CTL_BITS - num_on, 0, `T_RISE_FALL_DEFAULT * 1p);
    end

endmodule

module tb_termination;
    // TODO: Verify step size
    reg [`TERMINATION_CTL_BITS-1:0] zctl;
    reg en;
    electrical vin, vdd, vss;
    real vin_sample;
    
    termination term (
        .vin(vin),
        .zctl(zctl),
        .en(en),
        .vss(vss)
    );

    analog begin
        V(vdd) <+ `VDD;
        V(vss) <+ 0;
        I(vdd, vin) <+ V(vdd, vin) / `RX_R_IN;
        vin_sample = V(vin);
    end

    initial begin
        zctl = 0;
        en = 1;
    end

    integer i;
    reg actual;
    real vmid;
    initial begin
        vmid = `VDD/2;
        #300;

        // Check that lowest code is above 30 ohms
        $display("vin = %f, zctl = %b", vin_sample, zctl);
        if (vin_sample < vmid) $display("Error: highest termination impedance is too low (vmid = %f)", vmid);
        zctl = {`TERMINATION_CTL_BITS{1'b1}};
        #300;
        $display("vin = %f, zctl = %b", vin_sample, zctl);
        if (vin_sample > vmid) $display("Error: lowest termination impedance is too high (vmid = %f)", vmid);

        $finish;
    end
endmodule
