package edu.berkeley.cs.uciedigital.logphy

import chisel3.util._
import chisel3._
import chisel3.util.random._

class UCIeScrambler(afeParams: AfeParams, numLanes: Int) extends Module {
  val io = IO(new Bundle {
    val data_in = Input(Vec(numLanes, UInt(afeParams.mbSerializerRatio.W)))
    val valid = Input(Bool())
    val data_out = Output(Vec(numLanes, UInt(afeParams.mbSerializerRatio.W)))
  })
  val UCIe_seeds = List(
    /** seeds have to be reversed so that LSB ends up in rightmost position */
    "0011_1101_1111_1101_1011_100", // "1dbfbc",
    "11011101111000000110000", // "0607bb",
    "00000110111000110111100", // "1ec760",
    "11011011000000110001100", // "18c0db",
    "01001000111100001000000", // "010f12",
    "10010011111100111001100", // "19cfc9",
    "01110011111011100100000", // "0277ce",
    "11100000000111011101100", // "1bb807",
  )
  val seeds = (for (i <- 0 until numLanes) yield UCIe_seeds(i % 8)).toList
  val scramblers =
    seeds.map(seed => Module(new LFSR(afeParams, BigInt(seed, 2))))
  for (i <- 0 until scramblers.length) {
    scramblers(i).io.data_in := io.data_in(i)
    scramblers(i).io.valid := io.valid
    scramblers(i).reset := reset
    scramblers(i).clock := clock
    scramblers(i).io.seed := ("b" + seeds(i)).U(23.W)
    io.data_out(i) := scramblers(i).io.data_out
  }
}
