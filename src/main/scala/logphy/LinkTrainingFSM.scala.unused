package edu.berkeley.cs.uciedigital.logphy

import sideband._
import chisel3._
import chisel3.util._

case class AfeParams(
    sbSerializerRatio: Int = 1,
    sbWidth: Int = 1,
    mbSerializerRatio: Int = 32,
    mbLanes: Int = 16,
    STANDALONE: Boolean = true
)

object TimeoutConstants {
  def timeoutMap(mbSerializerRatio: Int, timeoutMs: Double = 0.008): Map[SpeedMode.Type, BigInt] = {

    // GT/s is divide by 2 because operating at DDR (half-rate clocking)
    Map(
      SpeedMode.speed4  -> (((2_000_000_000L / mbSerializerRatio) * timeoutMs).toLong),
      SpeedMode.speed8  -> (((4_000_000_000L / mbSerializerRatio) * timeoutMs).toLong),
      SpeedMode.speed12 -> (((6_000_000_000L / mbSerializerRatio) * timeoutMs).toLong),
      SpeedMode.speed16 -> (((8_000_000_000L / mbSerializerRatio) * timeoutMs).toLong),
      SpeedMode.speed24 -> (((12_000_000_000L / mbSerializerRatio) * timeoutMs).toLong),
      SpeedMode.speed32 -> (((16_000_000_000L / mbSerializerRatio) * timeoutMs).toLong),
      SpeedMode.speed48 -> (((24_000_000_000L / mbSerializerRatio) * timeoutMs).toLong),
      SpeedMode.speed64 -> (((32_000_000_000L / mbSerializerRatio) * timeoutMs).toLong)
    )
  }
}

object MBRxTxMode extends ChiselEnum {
  // Either send/receive RAW or process with valid framing
  val RAW, VALID_FRAME = Value
}
object MsgSource extends ChiselEnum {
  val PATTERN_GENERATOR, SB_MSG_WRAPPER = Value
}

case class LinkTrainingParams(
    /** The amount of cycles to wait after driving the PLL frequency */
    pllWaitTime: Int = 100,         // TODO: Isn't this indicated by pll lock?
    maxSBMessageSize: Int = 128,
    mbTrainingParams: MBTrainingParams = MBTrainingParams(),
    sbClockFreqAnalog: Int = 800_000_000,
    maxPatternCount: Int = 1 << 32,


    retryAmtWidth: Int = 3
)

// BEGIN: Bundles
class SidebandCtrlIO extends Bundle {
  val txEn        = Output(Bool())
  val rxEn        = Output(Bool())
  val rxTxMode    = Output(SBRxTxMode())
  val sbSerDesRst = Output(Bool()) // TODO: Planning to toggle this high during the 4ms wait coming into reset
  val sbPllLock   = Input(Bool())    
}

class MainbandCtrlIO(afeParams: AfeParams) extends Bundle {
  val txDataTriState    = Output(Vec(afeParams.mbLanes), Bool())
  val txClkTriState     = Output(Bool())
  val txValidTriState   = Output(Bool())
  val txTrackTriState   = Output(Bool())            
  val rxDataEn          = Output(Vec(afeParams.mbLanes), Bool())
  val rxClkEn           = Output(Bool())
  val rxValidEn         = Output(Bool())
  val rxTrackEn         = Output(Bool())
  val freqSel           = Output(SpeedMode())    
  val rxTxMode          = Output(MBRxTxMode())  
  val mbPllLock         = Input(Bool())
}

class SidebandLanes(sbMsgWidth: Int) extends Bundle {
  /*
    For internal logPHY IOs. As of UCIe 3.0, we don't use the sideband
    clock besides in the deserializer, so we don't include it here.
  */
  val data = Bits(sbMsgWidth.W)
}

class SidebandLaneIO(sbParams: SidebandParams) extends Bundle {  
    val tx = Decoupled(new SidebandLanes(sbParams.sbNodeMsgWidth))
    val rx = Flipped(Decoupled(new SidebandLanes(sbParams.sbNodeMsgWidth)))
}

class MainbandLanes(mbNumLanes: Int, mbSerializerRatio: Int) extends Bundle {
    val data    = Vec(mbNumLanes, Bits(mbSerializerRatio.W))
    val valid   = Bits(mbSerializerRatio.W)
    val clkP    = Bits(mbSerializerRatio.W)
    val clkN    = Bits(mbSerializerRatio.W)
    val trk     = Bits(mbSerializerRatio.W)
}

class MainbandLaneIO(afeParams: AfeParams) extends Bundle {
    val tx = Decoupled(
        new MainbandLanes(afeParams.numLanes, afeParams.mbSerializerRatio))
    val rx = Flipped(Decoupled(
        new MainbandLanes(afeParams.numLanes, afeParams.mbSerializerRatio)))
}

class SubFsmControlIO extends Bundle {
    val start = Input(Bool())
    val substateTransitioning = Output(Bool())
    val done = Output(Bool())
}
// END: Bundles


class LinkTrainingFSM(
  linkTrainingParams: LinkTrainingParams,
  sbParams: SidebandParams,
  afeParams: AfeParams,
) extends Module {

  object LTState extends ChiselEnum {
      val sRESET, sSBINIT, sMBINIT, sMBTRAIN, sLINKINIT, sACTIVE, sPHYRETRAIN, sTRAINERROR, sL1_L2  
      = Value
  }
    
    val retryAmtWidth = linkTrainingParams.retryAmtWidth
    val mbNumLanes = afeParams.mbLanes

    val io = IO(new Bundle {    

      // NOTE: out to logphytop
      val currentState = Output(LTState())                

      // NOTE: comes from ucie dvsec (controller in logphy)
      val retryTrainingAmt = Input(UInt(retryAmtWidth.W))   

      // NOTE: swTrigger from DVSEC regs, rdiTrigger from adapter 
      //       get both signals from logPHY controller
      val swTriggerTraining = Input(Bool())     
      val rdiTriggerTraining = Input(Bool())

      // TODO: Remove this signal. Pattern Reader will be instantiated in this module (LTSM)
      val remoteTriggerTraining = Input(Bool()) 

      // TODO: Implement bypass control of the FSM for debugging.
      val trainingBypass = Input(Bool())
      val selectStateBypass = Input(LTState())

      val trainingTimedOut = Output(Bool())

      // TODO: Need to figure out where this signal gets routed from.
      val pwrGood = Input(Bool())            

      /*
          If mainband has no valid data then hold low in mb serdes, if en == 1
          if en == 0, then tristate, clock gate, etc

          sideband are just held low -- no tristate or anything
      */
      val sidebandCtrlIo = new SidebandCtrlIO()
      val mainbandCtrlIo = new MainbandCtrlIO(afeParams)
      val sidebandLaneIo = new SidebandLaneIO(sbParams)           
      val mainbandLaneIo = new MainbandLaneIO(afeParams)
    })

  /*
    Notes:
    ELECTRICAL IDLE:
    - Some training states need electrical idle when Transmitters and 
    Receivers are waiting for generate and receive patterns.
    - Electrical idle on the mainband in this Specification is described as 
    when Transmitters and Receivers are enabled; Data, Valid and Track Lanes 
    are held low and Clock is parked at high and low.

    TIMEOUT:
    - Every state except RESET, Active, L1/L2 and TRAINERROR has a 8ms timeout
    Transition into TRAINERROR
        -- States with substate it is per substate
    -- Physical layer sideband handshakes for RDI state transitions with
    Remote Link partner also timeout after 8ms

    - Timeout reset is a sideband message with Stall encoding is recevied

    - All timeout values must beb set to specificed values after Domain Reset
    exit
    - All counter values must be set to the specified values after Domain Reset

    ATTEMPTING TRAINING DURING LINK INITIALIZATAION:
    1. SW writes 1 to start UCIe Link Training bit in DVSEC
    2. Adapter triggers Link Training on the RDI
        -- RDI status is Reset and there is a NOP to Active transition on
        the state request
    3. Observing the SBINIT pattern (two consection iterations of 64-UI
        clock pattern and 32-UI low on SB clock/data pair)
  */
  /*
    NOTES:
        -- Pattern Reader can look at the state of the LTSM and signal off its
        training trigger
    TODO:
    --- If HW fails training after an implementation-specific num of times,
    HW must transition to RESET and wait for a subsequent Link Training Trigger
        ==> Can have an implementation DVSEC register that say number of times
        to attempt training and link training FSM uses to auto initiate
        link training (ie doesn't have to wait for a subsequent trigger)
        ==> In the training_trigger OR with a retry signal and triggers
            -- retry signal consists of a prev_trigger reg and a counter that
            counts to implementation specific retry amt.
            Once counter is hit reset the counters and 

    TODO: In Controller
    --- Physical Layer must escalate a fatal error to the D2D adapter on
    the RDI if mainband software triggered or RDI trigger Link training fails
    OR there is a Link up to Link down transition due to a Physical Layer timeout  

    Reset: 
        TODO:
        
        - Local SoC/Firmware is not keeping the Physical Layer in RESET
            -- Probably done through DVSEC?
  */
  val mbSerializerRatio = afeParams.mbSerializerRatio
  val timeoutMs = 0.008
  val pwrGood = io.pwrGood
  val mbPllLock = io.mainband_ctrlIO.mbPllLock
  val sbPllLock = io.sideband_ctrlIO.sbPllLock

  val sbMsgSource = WireInit(MsgSource.PATTERN_GENERATOR)

  // BEGIN: Helper module instantiations and connections


  // TODO: Instantiate PatternWriter and PatternReader


  // END: Helper module instantiations and connections   

  val currentState = RegInit(LTState.sRESET)
  val nextState := WireInit(currentState) 

  /*
      Number of timeout cycles for sideband messages
      - Digital operates with divided mainband clock to prevent 
        clock crossings inside of digital.
  */    
  val timeoutMapScala = TimeoutConstants.timeoutMap(mbSerializerRatio, timeoutMs)
  val timeoutWidth = log2Ceil(timeoutMapScala.values.max)
  val timeoutCyclesMax = Wire(UInt(timeoutWidth.W))
  val timeoutCntEn = Wire(Bool())       // disable next cycle
  val timeoutCntReset = Wire(Bool())    // reset next cycle
  val trainingTimedOut = Wire(Bool())

  val timeoutCounter = RegInit(0.U(timeout_width.W))
  val resetMinWait = RegInit(false.B)    
  val substateTransitioning = Wire(Bool())
  
  timeoutCntEn := (currentState =/= LTState.sRESET) 
                && (currentState =/= LTState.sACTIVE)
                && (currentState =/= LTState.sL1_L2)
                && (currentState =/= LTState.sTRAINERROR)

  timeoutCntReset := (nextState =/= currentState) || substateTransitioning

  io.trainingTimedOut := trainingTimedOut
  trainingTimedOut := timeoutCounter === timeoutCyclesMax
  
  timeoutCyclesMax := (timeoutMapScala.values.min - 1).U

  // get correct timeout cycles based on PHY speed we are on
  switch(io.mainbandCtrlIo.freqSel) { 
      for ((speedMode, numTimeoutCycles) <- timeoutMapScala) {
          is(speedMode) { timeoutCyclesMax := (numTimeoutCycles - 1).U }
      }
  }
  
  // timeout counter
  when(timeoutCntReset) {
      timeoutCounter := 0.U
  }.otherwise {
      when(timeoutCntEn){
          when(timeoutCounter === timeoutCyclesMax) {
              timeoutCounter := timeoutCyclesMax                
          }.otherwise {
              timeoutCounter := timeoutCounter + 1.U
          }
      }
  }

  // wait a minimum of 4ms upon entering RESET   
  when(timeoutCounter === (timeoutCyclesMax >> 2) 
        && (currentState === LTState.sRESET)) {
      resetMinWait := true.B        
  }.elsewhen((currentState =/= LTState.sRESET) 
              && nextState === LTState.sRESET) {
      resetMinWait := false.B
  }

  // can retry training an implementation specific amount of time without 
  // a subsequent trigger
  val triggerTraining = Wire(Bool())
  triggerTraining := io.swTriggerTraining || io.rdiTriggerTraining 
                      || io.remoteTriggerTraining


  val prev_trigger = RegInit(false.B)
  val training_retry_counter = RegInit(0.U(retry_amt_w.W))
  val auto_retrain = Wire(Bool())
  val retry_amt = Reg(UInt(retry_amt_w.W))
  val retry_counter_en = Wire(Bool())

  retry_amt := io.retry_training_amt    

  retry_counter_en := (current_state === LTState.sTRAINERROR) && 
                      (next_state === LTState.sRESET)

  // TODO: FIX prev-trigger

  when(retry_amt =/= 0.U && training_retry_counter === 0.U 
       && current_state === LTState.sRESET) {
      prev_trigger := trigger_training
  }

  when(retry_counter_en && prev_trigger) {
      training_retry_counter := training_retry_counter + 1.U
  }

  when(retry_amt =/= 0.U && training_retry_counter === 0.U) {

  }

  auto_retrain := (training_retry_counter =/= retry_amt) && prev_trigger
  
  
  // TODO:
  // NOTE: Transition into TrainError using training_timedout or partnerTrainError
  // There also needs to be a message timer on the response of the TrainError response
  // but to make it easier just exit to trainerror what's the point on waiting
  // for the response? Loopback testing...


  // Defaults
  val sbCtrlIo = Wire(new SidebandCtrlIO())    
  sbCtrlIo.txEn := true.B
  sbCtrlIo.rxEn := true.B
  sbCtrlIo.rxtxMode := SBRxTxMode.RAW
  sbCtrlIo <> io.sidebandCtrlIo

  val mbCtrlIo = Wire(new MainbandCtrlIO())
  mbCtrlIo.txDataTriState := true.B
  mbCtrlIo.txClkTriState := true.B
  mbCtrlIo.txValidTriState := true.B
  mbCtrlIo.txTrackTriState := true.B

  mbCtrlIo.rxDataEn := false.B
  mbCtrlIo.rxClkEn := false.B
  mbCtrlIo.rxValidEn := false.B
  mbCtrlIo.rxTrackEn := false.B

  mbCtrlIo.freqSel := SpeedMode.speed4
  mbCtrlIo.rxTxMode := MBRxTxMode.RAW
  mbCtrlIo <> io.mainbandCtrlIo
  

  // BEGIN: Substate module instantiations and default connections
  /* 
      Note: training_timedout asserts async, but deasserts sync during state
            transition
              -- the timeout counter resets with state transition
  */
  // TODO: this might be a bad idea to have because if we get a timeout
  // in the message passing into error then what? 
  val subFsmModuleReset = (reset.asBool || trainingTimedOut).asAsyncReset

  val subFsmCtrlIo = Wire(new SubFsmControlIO())
  subFsmCtrlIo.start := false.B
  substateTransitioning := subFsmCtrlIo.substateTransitioning := false.B
  subFsmCtrlIo.done := false.B

  // SBInit
  val sbInitModule = WithReset(subFsmModuleReset) {
      Module(new SBInitSM(linkTrainingParams, sbParams, afeParams))
  }

  val sbInitFsmCtrlIo = WireDefault(0.U.asTypeOf(new SubFsmControlIO()))
  val sbInitSbCtrlIo = WireDefault(0.U.asTypeOf(new SidebandCtrlIO()))
  val sbInitMbCtrlIo = WireDefault(0.U.asTypeOf(new MainbandCtrlIO()))
  val sbInitSbMsgIo = WireDefault(0.U.asTypeOf(
                                      Flipped(new SBMsgWrapperTrainIO())))
  val sbInitPatterGenIo = WireDefault(0.U.asTypeOf(
                                      Flipped(new PatternGeneratorIO(afeParams, 
                                                          maxPatternCount))))

  sbInitModule.io.fsmCtrl <> sbInitFsmCtrlIo
  sbInitModule.io.sidebandCtrl <> sbInitSbCtrlIo
  sbInitModule.io.mainbandCtrl <> sbInitMbCtrlIo
  sbInitModule.io.sbMsgIo <> sbInitSbMsgIo
  sbInitModule.io.patternGenIo <> sbInitPatterGenIo
  
  // MBInit TODO


  // MBTrain TODO

  // END: Substate module instantiations and default connections


  currentState := nextState
  switch(currentState) {
    is(LTState.sRESET) {            
        /*  
        Default signals:
            Data, Valid, Clock TX are tri-state (tristate == 1)
            Data, Valid, Clock RX are disabled (en == 0)
            Sideband TX is enabled (en == 1)
            Sideband RX is enabled (en == 1)                
            Set Mainband Clock Speed to lowest (4 GT/s)
        */
        when(pwrGood && sbPllLock && mbPllLock && resetMinWait
              && triggerTraining) {
            nextState := LTState.sSBINIT
        }.otherwise {
            nextState := LTState.sRESET
        }
    }



    is(LTState.sSBINIT) {        
        // defaults to sideband and mainband io are set inside the module
        subFsmCtrlIo.start := true.B
        subFsmCtrlIo <> sbInitFsmCtrlIo
        sbCtrlIo <> sbInitSbCtrlIo
        mbCtrlIo <> sbInitMbCtrlIo

        when(subFsmCtrlIo.done) {
            // transition
        }
        // logic for when there's a timeout

    }

  }
}


